<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>OnionStream Player</title>
    <style>
        body {
            background: black;
            color: white;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
        }

        canvas {
            border: 2px solid #ccc;
        }
    </style>
</head>

<body>
    <h1>OnionStream Player</h1>

    <label for="streamSelect">Select Stream:</label>
    <select id="streamSelect">
        <option disabled selected>Loading...</option>
    </select>

    <canvas id="video" width="640" height="480"></canvas>
    <div id="status"></div>
    <div id="audioStatus"></div>
    <div style="margin: 10px;">
        <label>
            <input type="checkbox" id="audioEnabled" checked> Enable Audio
        </label>
        <button id="audioInit" onclick="initializeAudioManually()" style="margin-left: 10px;">Initialize Audio</button>
    </div>
    <button id="reconnectBtn" onclick="manualReconnect()" style="display: none;">Reconnect</button>

    <script src="/static/h264decoder/bundle.js"></script>
    <script src="/static/opus-decoder/opus-decoder.min.js"></script>
    <script>
        const canvas = document.getElementById("video");
        const ctx = canvas.getContext("2d");
        let imageData = ctx.createImageData(canvas.width, canvas.height);

        // Stream management
        const streams = new Map(); // Store multiple stream connections
        let currentStreamId = null;

        // Video decoder
        const decoder = new H264DecoderModule.H264Decoder();

        // Audio decoder and context
        let audioDecoder = null;
        let audioContext = null;
        let audioQueue = [];
        let isAudioPlaying = false;
        let nextPlayTime = 0;

        // Stream connection class
        class StreamConnection {
            constructor(streamId, streamType, options = {}) {
                this.streamId = streamId;
                this.streamType = streamType; // 'video', 'audio', etc.
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = options.maxReconnectAttempts || 10;
                this.reconnectDelay = 1000;
                this.reconnectTimer = null;
                this.isReconnecting = false;
                this.receiveTimeout = options.receiveTimeout || 3000;
                this.receiveTimer = null;
                this.lastReceiveTime = 0;
                this.onMessage = options.onMessage || null;
                this.onStatusChange = options.onStatusChange || null;
            }

            showStatus(message, isError = false) {
                const statusElement = document.getElementById('status');
                const reconnectBtn = document.getElementById('reconnectBtn');

                if (statusElement) {
                    statusElement.textContent = `[${this.streamType.toUpperCase()}] ${message}`;
                    statusElement.style.color = isError ? 'red' : 'green';
                }

                // Show reconnect button if connection failed and we're not already reconnecting
                if (isError && this.reconnectAttempts >= this.maxReconnectAttempts && reconnectBtn) {
                    reconnectBtn.style.display = 'block';
                } else if (reconnectBtn) {
                    reconnectBtn.style.display = 'none';
                }

                if (this.onStatusChange) {
                    this.onStatusChange(message, isError);
                }
            }

            resetReconnectState() {
                this.reconnectAttempts = 0;
                this.reconnectDelay = 1000;
                this.isReconnecting = false;
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }
                if (this.receiveTimer) {
                    clearTimeout(this.receiveTimer);
                    this.receiveTimer = null;
                }
            }

            startReceiveTimeout() {
                if (this.receiveTimer) {
                    clearTimeout(this.receiveTimer);
                }

                this.receiveTimer = setTimeout(() => {
                    console.log(`[${this.streamType}] Receive timeout - no data received for`, this.receiveTimeout / 1000, "seconds");
                    this.showStatus("No data received, reconnecting...", true);
                    if (this.ws) {
                        this.ws.close(1000, "Receive timeout");
                    }
                    this.scheduleReconnect();
                }, this.receiveTimeout);
            }

            resetReceiveTimeout() {
                this.lastReceiveTime = Date.now();
                this.startReceiveTimeout();
            }

            scheduleReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    this.showStatus(`Failed to reconnect after ${this.maxReconnectAttempts} attempts`, true);
                    return;
                }

                if (this.isReconnecting) {
                    return;
                }

                this.isReconnecting = true;
                this.reconnectAttempts++;

                this.showStatus(`Reconnecting... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`, true);

                this.reconnectTimer = setTimeout(() => {
                    this.connect(true);
                }, this.reconnectDelay);

                // Exponential backoff with jitter
                this.reconnectDelay = Math.min(this.reconnectDelay * 2 + Math.random() * 1000, 30000);
            }

            connect(isReconnect = false) {
                if (this.ws) {
                    this.ws.close();
                }

                if (!isReconnect) {
                    this.resetReconnectState();
                }

                const host = window.location.hostname;
                const url = `ws://${host}/stream/live/${this.streamId}/${this.streamType}`;
                console.log(`[${this.streamType}] Connecting to stream:`, url);

                this.ws = new WebSocket(url);
                this.ws.binaryType = "arraybuffer";

                this.ws.onopen = () => {
                    console.log(`[${this.streamType}] WebSocket connected`);
                    this.resetReconnectState();
                    this.showStatus("Connected to stream");
                    this.startReceiveTimeout();
                };

                this.ws.onmessage = (event) => {
                    this.resetReceiveTimeout();

                    if (!(event.data instanceof ArrayBuffer)) {
                        console.warn(`[${this.streamType}] Non-binary message received`);
                        return;
                    }

                    if (this.onMessage) {
                        this.onMessage(event.data);
                    }
                };

                this.ws.onerror = (err) => {
                    console.error(`[${this.streamType}] WebSocket error:`, err);
                    if (!this.isReconnecting) {
                        this.showStatus("Connection error", true);
                    }
                };

                this.ws.onclose = (event) => {
                    console.log(`[${this.streamType}] WebSocket closed:`, event.code, event.reason);

                    // Clear receive timeout when connection closes
                    if (this.receiveTimer) {
                        clearTimeout(this.receiveTimer);
                        this.receiveTimer = null;
                    }

                    // Check if this was an unexpected close (not user-initiated)
                    if (event.code !== 1000 && event.code !== 1001 && !isReconnect) {
                        this.showStatus("Connection lost, attempting to reconnect...", true);
                        this.scheduleReconnect();
                    } else if (event.code !== 1000 && event.code !== 1001 && isReconnect) {
                        this.scheduleReconnect();
                    } else {
                        this.showStatus("Disconnected", true);
                    }
                };
            }

            disconnect() {
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }
                if (this.receiveTimer) {
                    clearTimeout(this.receiveTimer);
                    this.receiveTimer = null;
                }

                if (this.ws) {
                    this.ws.close(1000, "User disconnect");
                    this.ws = null;
                }

                this.resetReconnectState();
            }
        }

        // Video-specific message handler
        function handleVideoMessage(data) {
            const dataArray = new Uint8Array(data);
            const result = decoder.decode(dataArray);

            if (result === H264DecoderModule.H264Decoder.PIC_RDY) {
                renderFrame();
            } else if (result === H264DecoderModule.H264Decoder.ERROR) {
                console.error("Decoder error");
            } else if (result === H264DecoderModule.H264Decoder.PARAM_SET_ERROR) {
                console.error("Parameter set error");
            } else if (result === H264DecoderModule.H264Decoder.MEMALLOC_ERROR) {
                console.error("Memory allocation error");
            } else {
                console.log("Decoder result:", result);
            }
        }

        // Initialize audio system
        async function initializeAudio() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                if (!audioDecoder) {
                    audioDecoder = new window["opus-decoder"].OpusDecoder();
                    await audioDecoder.ready;
                    console.log("Opus decoder initialized");
                }

                return true;
            } catch (error) {
                console.error("Failed to initialize audio:", error);
                return false;
            }
        }

        // Play audio buffer
        function playAudioBuffer(channelData, sampleRate) {
            if (!audioContext || !channelData || channelData.length === 0) {
                return;
            }

            try {
                const numberOfChannels = channelData.length;
                const numberOfFrames = channelData[0].length;

                const audioBuffer = audioContext.createBuffer(numberOfChannels, numberOfFrames, sampleRate);

                // Copy channel data to audio buffer
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const channelBuffer = audioBuffer.getChannelData(channel);
                    for (let i = 0; i < numberOfFrames; i++) {
                        channelBuffer[i] = channelData[channel][i];
                    }
                }

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);

                // Schedule playback to maintain proper timing
                const currentTime = audioContext.currentTime;
                if (nextPlayTime < currentTime) {
                    nextPlayTime = currentTime;
                }

                source.start(nextPlayTime);
                nextPlayTime += audioBuffer.duration;

            } catch (error) {
                console.error("Error playing audio buffer:", error);
            }
        }

        // Audio-specific message handler
        async function handleAudioMessage(data) {
            // Check if audio is enabled
            const audioEnabled = document.getElementById('audioEnabled');
            if (!audioEnabled || !audioEnabled.checked) {
                return;
            }

            if (!audioDecoder) {
                const initialized = await initializeAudio();
                if (!initialized) {
                    updateAudioStatus("Failed to initialize audio decoder", true);
                    return;
                }
                updateAudioStatus("Audio decoder initialized");
            }

            try {
                // Resume audio context if it's suspended (required for some browsers)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    updateAudioStatus("Audio context resumed");
                }

                const opusFrame = new Uint8Array(data);

                // Decode the Opus frame
                const { channelData, samplesDecoded, sampleRate } = audioDecoder.decodeFrame(opusFrame);

                if (samplesDecoded > 0 && channelData) {
                    // Play the decoded audio
                    playAudioBuffer(channelData, sampleRate);

                    // Update status occasionally (not every frame to avoid spam)
                    if (Math.random() < 0.01) { // 1% chance to update status
                        updateAudioStatus(`Playing: ${samplesDecoded} samples at ${sampleRate}Hz`);
                    }
                }

            } catch (error) {
                console.error("Error decoding audio:", error);
                updateAudioStatus(`Decoding error: ${error.message}`, true);
            }
        }

        function showStatus(message, isError = false) {
            const statusElement = document.getElementById('status');
            const reconnectBtn = document.getElementById('reconnectBtn');

            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.color = isError ? 'green' : 'red';
            }

            // Show reconnect button if connection failed
            if (isError && reconnectBtn) {
                reconnectBtn.style.display = 'block';
            } else if (reconnectBtn) {
                reconnectBtn.style.display = 'none';
            }
        }

        function resetReconnectState() {
            // This function is now handled by individual StreamConnection instances
        }

        function startReceiveTimeout() {
            // This function is now handled by individual StreamConnection instances
        }

        function resetReceiveTimeout() {
            // This function is now handled by individual StreamConnection instances
        }

        function scheduleReconnect() {
            // This function is now handled by individual StreamConnection instances
        }

        function renderFrame() {
            const width = decoder.width;
            const height = decoder.height;
            const yuvBuffer = decoder.pic;

            // console.log("Picture decoded:", width, height);

            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                imageData = ctx.createImageData(width, height);
            }

            // Convert YUV420 to RGB
            const yPlane = yuvBuffer.subarray(0, width * height);
            const uPlane = yuvBuffer.subarray(width * height, width * height + (width * height) / 4);
            const vPlane = yuvBuffer.subarray(width * height + (width * height) / 4, width * height + (width * height) / 2);

            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const yIndex = y * width + x;
                    const uvIndex = (y >> 1) * (width >> 1) + (x >> 1);

                    const Y = yPlane[yIndex];
                    const U = uPlane[uvIndex] - 128;
                    const V = vPlane[uvIndex] - 128;

                    // YUV to RGB conversion
                    const R = Math.max(0, Math.min(255, Y + 1.402 * V));
                    const G = Math.max(0, Math.min(255, Y - 0.344 * U - 0.714 * V));
                    const B = Math.max(0, Math.min(255, Y + 1.772 * U));

                    const offset = yIndex * 4;
                    data[offset] = R;
                    data[offset + 1] = G;
                    data[offset + 2] = B;
                    data[offset + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        async function fetchStreams() {
            try {
                const res = await fetch("/stream/stream_list");
                const streams = await res.json();
                const select = document.getElementById("streamSelect");
                select.innerHTML = "";

                for (const stream of streams) {
                    const option = document.createElement("option");
                    option.value = stream;
                    option.textContent = stream;
                    select.appendChild(option);
                }

                if (streams.length > 0) {
                    select.selectedIndex = 0;
                    connectToStream(streams[0]);
                } else {
                    console.warn("No available streams.");
                }
            } catch (err) {
                console.error("Failed to fetch stream list:", err);
            }
        }

        function connectToStream(streamId, isReconnect = false) {
            // Disconnect existing streams
            streams.forEach(stream => stream.disconnect());
            streams.clear();

            currentStreamId = streamId;

            // Create video stream connection
            const videoStream = new StreamConnection(streamId, 'video', {
                maxReconnectAttempts: 10,
                receiveTimeout: 3000,
                onMessage: handleVideoMessage,
                onStatusChange: (message, isError) => {
                    // You can add custom status handling here
                }
            });

            // Create audio stream connection
            const audioStream = new StreamConnection(streamId, 'audio', {
                maxReconnectAttempts: 10,
                receiveTimeout: 3000,
                onMessage: handleAudioMessage,
                onStatusChange: (message, isError) => {
                    updateAudioStatus(message, isError);
                }
            });

            streams.set('video', videoStream);
            streams.set('audio', audioStream);

            // Connect to streams
            videoStream.connect(isReconnect);
            audioStream.connect(isReconnect);
        }

        function manualReconnect() {
            if (currentStreamId) {
                connectToStream(currentStreamId);
            }
        }

        // Manual audio initialization (for user gesture requirement)
        async function initializeAudioManually() {
            const success = await initializeAudio();
            const audioStatus = document.getElementById('audioStatus');
            if (audioStatus) {
                audioStatus.textContent = success ? 'Audio initialized successfully' : 'Failed to initialize audio';
                audioStatus.style.color = success ? 'green' : 'red';
            }
        }

        // Update audio status
        function updateAudioStatus(message, isError = false) {
            const audioStatus = document.getElementById('audioStatus');
            if (audioStatus) {
                audioStatus.textContent = `[AUDIO] ${message}`;
                audioStatus.style.color = isError ? 'red' : 'green';
            }
        }

        // Cleanup audio resources
        async function cleanupAudio() {
            try {
                if (audioDecoder) {
                    await audioDecoder.free();
                    audioDecoder = null;
                }
                if (audioContext && audioContext.state !== 'closed') {
                    await audioContext.close();
                    audioContext = null;
                }
                audioQueue = [];
                nextPlayTime = 0;
                updateAudioStatus("Audio resources cleaned up");
            } catch (error) {
                console.error("Error cleaning up audio:", error);
            }
        }

        document.getElementById("streamSelect").addEventListener("change", (e) => {
            // Clear any existing streams when switching
            streams.forEach(stream => stream.disconnect());
            streams.clear();

            connectToStream(e.target.value);
        });

        // Audio control event listeners
        document.getElementById("audioEnabled").addEventListener("change", (e) => {
            if (!e.target.checked) {
                updateAudioStatus("Audio disabled");
            } else {
                updateAudioStatus("Audio enabled - waiting for data");
            }
        });

        // Cleanup on page unload
        window.addEventListener("beforeunload", () => {
            cleanupAudio();
            streams.forEach(stream => stream.disconnect());
        });

        fetchStreams();
    </script>
</body>

</html>