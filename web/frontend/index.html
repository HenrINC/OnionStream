<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>OnionStream Player</title>
    <style>
        body {
            background: black;
            color: white;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
        }

        canvas {
            border: 2px solid #ccc;
        }
    </style>
</head>

<body>
    <h1>OnionStream Player</h1>

    <label for="streamSelect">Select Stream:</label>
    <select id="streamSelect">
        <option disabled selected>Loading...</option>
    </select>

    <canvas id="video" width="640" height="480"></canvas>
    <div id="status"></div>
    <button id="reconnectBtn" onclick="manualReconnect()" style="display: none;">Reconnect</button>

    <script src="/static/h264decoder/bundle.js"></script>
    <script>
        const canvas = document.getElementById("video");
        const ctx = canvas.getContext("2d");
        let imageData = ctx.createImageData(canvas.width, canvas.height);
        let ws = null;
        let currentStreamId = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectDelay = 1000; // Start with 1 second
        let reconnectTimer = null;
        let isReconnecting = false;
        let receiveTimeout = 3000; // 3 seconds timeout
        let receiveTimer = null;
        let lastReceiveTime = 0;

        const decoder = new H264DecoderModule.H264Decoder();

        function showStatus(message, isError = false) {
            const statusElement = document.getElementById('status');
            const reconnectBtn = document.getElementById('reconnectBtn');

            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.color = isError ? 'red' : 'green';
            }

            // Show reconnect button if connection failed and we're not already reconnecting
            if (isError && reconnectAttempts >= maxReconnectAttempts && reconnectBtn) {
                reconnectBtn.style.display = 'block';
            } else if (reconnectBtn) {
                reconnectBtn.style.display = 'none';
            }
        }

        function resetReconnectState() {
            reconnectAttempts = 0;
            reconnectDelay = 1000;
            isReconnecting = false;
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
            if (receiveTimer) {
                clearTimeout(receiveTimer);
                receiveTimer = null;
            }
        }

        function startReceiveTimeout() {
            if (receiveTimer) {
                clearTimeout(receiveTimer);
            }

            receiveTimer = setTimeout(() => {
                console.log("Receive timeout - no data received for", receiveTimeout / 1000, "seconds");
                showStatus("No data received, reconnecting...", true);
                if (ws) {
                    ws.close(1000, "Receive timeout");
                }
                scheduleReconnect();
            }, receiveTimeout);
        }

        function resetReceiveTimeout() {
            lastReceiveTime = Date.now();
            startReceiveTimeout();
        }

        function scheduleReconnect() {
            if (reconnectAttempts >= maxReconnectAttempts) {
                showStatus(`Failed to reconnect after ${maxReconnectAttempts} attempts`, true);
                return;
            }

            if (isReconnecting) {
                return;
            }

            isReconnecting = true;
            reconnectAttempts++;

            showStatus(`Reconnecting... (attempt ${reconnectAttempts}/${maxReconnectAttempts})`, true);

            reconnectTimer = setTimeout(() => {
                if (currentStreamId) {
                    connectToStream(currentStreamId, true);
                }
            }, reconnectDelay);

            // Exponential backoff with jitter
            reconnectDelay = Math.min(reconnectDelay * 2 + Math.random() * 1000, 30000);
        }

        function renderFrame() {
            const width = decoder.width;
            const height = decoder.height;
            const yuvBuffer = decoder.pic;

            // console.log("Picture decoded:", width, height);

            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                imageData = ctx.createImageData(width, height);
            }

            // Convert YUV420 to RGB
            const yPlane = yuvBuffer.subarray(0, width * height);
            const uPlane = yuvBuffer.subarray(width * height, width * height + (width * height) / 4);
            const vPlane = yuvBuffer.subarray(width * height + (width * height) / 4, width * height + (width * height) / 2);

            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const yIndex = y * width + x;
                    const uvIndex = (y >> 1) * (width >> 1) + (x >> 1);

                    const Y = yPlane[yIndex];
                    const U = uPlane[uvIndex] - 128;
                    const V = vPlane[uvIndex] - 128;

                    // YUV to RGB conversion
                    const R = Math.max(0, Math.min(255, Y + 1.402 * V));
                    const G = Math.max(0, Math.min(255, Y - 0.344 * U - 0.714 * V));
                    const B = Math.max(0, Math.min(255, Y + 1.772 * U));

                    const offset = yIndex * 4;
                    data[offset] = R;
                    data[offset + 1] = G;
                    data[offset + 2] = B;
                    data[offset + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        async function fetchStreams() {
            try {
                const res = await fetch("/stream/stream_list");
                const streams = await res.json();
                const select = document.getElementById("streamSelect");
                select.innerHTML = "";

                for (const stream of streams) {
                    const option = document.createElement("option");
                    option.value = stream;
                    option.textContent = stream;
                    select.appendChild(option);
                }

                if (streams.length > 0) {
                    select.selectedIndex = 0;
                    connectToStream(streams[0]);
                } else {
                    console.warn("No available streams.");
                }
            } catch (err) {
                console.error("Failed to fetch stream list:", err);
            }
        }

        function connectToStream(streamId, isReconnect = false) {
            if (ws) {
                ws.close();
            }

            currentStreamId = streamId;

            if (!isReconnect) {
                resetReconnectState();
            }

            const host = window.location.hostname;
            const url = `ws://${host}/stream/live/${streamId}`;
            console.log("Connecting to stream:", url);

            ws = new WebSocket(url);
            ws.binaryType = "arraybuffer";

            ws.onopen = () => {
                console.log("WebSocket connected");
                resetReconnectState();
                showStatus("Connected to stream");
                startReceiveTimeout(); // Start the receive timeout
            };

            ws.onmessage = (event) => {
                resetReceiveTimeout(); // Reset timeout on each message

                if (!(event.data instanceof ArrayBuffer)) {
                    console.warn("Non-binary message received");
                    return;
                }

                const data = new Uint8Array(event.data);
                const result = decoder.decode(data);

                if (result === H264DecoderModule.H264Decoder.PIC_RDY) {
                    renderFrame();
                } else if (result === H264DecoderModule.H264Decoder.ERROR) {
                    console.error("Decoder error");
                } else if (result === H264DecoderModule.H264Decoder.PARAM_SET_ERROR) {
                    console.error("Parameter set error");
                } else if (result === H264DecoderModule.H264Decoder.MEMALLOC_ERROR) {
                    console.error("Memory allocation error");
                } else {
                    console.log("Decoder result:", result);
                }
            };

            ws.onerror = (err) => {
                console.error("WebSocket error:", err);
                if (!isReconnecting) {
                    showStatus("Connection error", true);
                }
            };

            ws.onclose = (event) => {
                console.log("WebSocket closed:", event.code, event.reason);

                // Clear receive timeout when connection closes
                if (receiveTimer) {
                    clearTimeout(receiveTimer);
                    receiveTimer = null;
                }

                // Check if this was an unexpected close (not user-initiated)
                if (event.code !== 1000 && event.code !== 1001 && currentStreamId && !isReconnect) {
                    showStatus("Connection lost, attempting to reconnect...", true);
                    scheduleReconnect();
                } else if (event.code !== 1000 && event.code !== 1001 && currentStreamId && isReconnect) {
                    scheduleReconnect();
                } else {
                    showStatus("Disconnected", true);
                }
            };
        }

        function manualReconnect() {
            reconnectAttempts = 0;
            reconnectDelay = 1000;
            isReconnecting = false;

            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            if (currentStreamId) {
                connectToStream(currentStreamId);
            }
        }

        document.getElementById("streamSelect").addEventListener("change", (e) => {
            // Clear any existing reconnection attempts when switching streams
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
            if (receiveTimer) {
                clearTimeout(receiveTimer);
                receiveTimer = null;
            }
            isReconnecting = false;

            connectToStream(e.target.value);
        });

        fetchStreams();
    </script>
</body>

</html>